<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <style>

    .legend {
      fill: gray;
      font-size: 14px;
      text-anchor: left;
    }

    .selected {
      font-weight: bold;
      fill: red;
    }

    .axis path,
    .axis line {
      fill: none;
      stroke: black;
      stroke-width: 1px;
      shape-rendering: crispEdges;  
    }

    .axis text {
      font-family: sans-serif;
      font-size: 11px;
    }

    .focus {
      opacity: 1;
      stroke: #185195;
    }

    .focus line {
      stroke-width: 1px;
    }

    .focus circle {
      fill: none;
      stroke-width: 2px;
    }

    .focus text {
      font-family: sans-serif;
      font-size: 20px;
      fill: #185195;
    }

    #tooltip {
      position: absolute;
      width: 170px;
      height: auto;
      padding: 5px 10px;
      right: 70px;
      font-weight: 500;
      background-color: rgba(250, 250, 250, 0.9);
      -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
      -moz-box-shadow: 0 0 5px rgba(0, 0, 0, 0.7);
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.7);
      pointer-events: none;
    }

    #tooltip text {
      margin: 0;
      font-size: 12px;
    }

    .hidden {
      display: none;
    }

    </style>
    <title>WiFi packets as seen from the space</title>
  </head>
  <body>
  <div id="tooltip" class="hidden">
  </div>
  <script type='text/javascript'
        src='//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js'></script>
      <script type='text/javascript' src='http://d3js.org/d3.v3.min.js'></script>
      <script type='text/javascript'>
        // TODO(katepek): Move into a separate JS file

        // TODO(katepek): Top-level TODOs:
        // * moving crosshairs is slow. Execution of the code in search and draw methods
        // take a couple of ms. Timeline of Developer Tools in Chrome shows that groups
        // of Paint methods take up to half a second (see TimelineRawData-20150107T133507
        // in sandbox/)
        "use strict";

        var debug = false;
        function log(o) {
          if (debug) {
            console.log(o);
          }
        }

        var w = window,
            d = document,
            e = d.documentElement,
            g = d.getElementsByTagName('body')[0];

        var total_width = w.innerWidth || e.clientWidth || g.clientWidth;
        var total_height = w.innerHeight || e.clientHeight || g.clientHeight;
        var sidebar_width = 180;
        var width; // of a plot
        var height; // of a plot
        var padding = 20;
        var tooltipLabelsHeight = 15; // height per line in detailed mouseover view

        var field_settings = {
          'pcap_secs': {
            'parser': parseFloat,
            'scale_type': d3.scale.linear(),
          },
          'seq': {
            'parser': Number,
            'scale_type': d3.scale.linear(),
          },
          'rate': {
            'parser': Number,
            'scale_type': d3.scale.log(),
          },
          'default': {
            'parser': parseFloat,
            'scale_type': d3.scale.linear(),
          }
        }

        var availableMetrics = ["antenna",
            "channel_flags", 
            "dbm_antnoise", 
            "dbm_antsignal",
            "dsmode", 
            "duration", 
            "flags",
            "frag",
            "freq",
            "incl_len",
            "mac_usecs",
            "order",
            "orig_len",
            "pcap_secs",
            "powerman",
            "ta",
            "type",
            "typestr",
            "ra",
            "rate",
            "retry",
            "seq",
            "xa"];

        function settings(field) {
          if (field_settings.hasOwnProperty(field))
            return field_settings[field];
          return field_settings['default'];
        }

        var to_plot = []; // fields to be plotted against X axis (time)
        var scales  = {}; // dict[field; scale], incl. X axis
        var reticle = {}; // dict[field; crosshair]

        var dataset; // all packets, sorted by pcap_secs
        var streams; // streams: pairs of (transmitter, receiver)
        // dataset split by streams as a list of key-value pairs (key ='ta-ra')
        // sorted descending by the number of packets belonging to each stream
        var stream2packets;

        // When not null, crosshairs will focus only on packets for this stream.
        var selected_stream = null; // one of the key-value pairs of stream2packets

        try {
          $.getJSON('/json/' + get_query_param('key')[0], function(json) {
              var begin = new Date().getTime();

              init(JSON.stringify(json));
              draw();

              var end = new Date().getTime();
              log('Spent on visualization ' + ((end - begin) / 1000) + ' sec.');
          });
        } catch (error) {
          console.log(error);
        }


        function get_key() {
          parts = window.location.pathname.split('/');
          return parts[parts.length - 1];
        }

        function get_query_param(param) {
         var params = window.location.search.substring(1).split('&');
         for (var idx in params) {
           if (params[idx].indexOf(param + '=') == 0)
             return params[idx].split('=')[1].split(',');
         }
         return [];
        }

        function to_stream_key(d) {
          return d['ta'] + '-' + d['ra'];
        }

        function from_stream_key(key) {
          return {'ta': key.split('-')[0], 'ra': key.split('-')[1]};
        }

        function to_valid_selector_id(key) {
          return key.replace(/:/g, '').replace('-', '_');
        }

        function init(json_string) {
          // TODO(katepek): Should sanitize here? E.g., discard bad packets?
          // Packets w/o seq?
          var js_objects = JSON.parse(json_string);
          dataset = JSON.parse(js_objects['js_packets']);

          streams = JSON.parse(js_objects['js_streams']);

          to_plot = get_query_param('to_plot');

          // Leave only packets that have all the fields that we want to plot
          // and the values there are positive
          sanitize_dataset();

          dataset.sort(function(x, y) {
            return raw('pcap_secs')(x) - raw('pcap_secs')(y);
          });

          // zan: todo - make this a dictionary? 
          stream2packets = d3.nest()
            .key(function(d) {return to_stream_key(d);})
            .sortKeys(function(key1, key2) {
              var stream1 = from_stream_key(key1);
              var stream2 = from_stream_key(key2);
              var stream1_packets = dataset.filter(function(d) {
                return d['ta'] == stream1['ta'] &&
                       d['ra'] == stream1['ra'];
              });
              var stream2_packets = dataset.filter(function(d) {
                return d['ta'] == stream2['ta'] &&
                       d['ra'] == stream2['ra'];
              });

              return stream2_packets.length - stream1_packets.length;
            })
            .entries(dataset);

          // TODO(katepek): Recalculate and redraw when resized
          height = (total_height - 3 * to_plot.length * padding) / to_plot.length;
          width = total_width - 4 * padding - sidebar_width;

          var x_range = [padding, width - 3 * padding];
          var y_range = [height - 1.5 * padding, 1.5 * padding];

          log('total_height = ' + total_height);
          log('height = ' + height);

          add_scale('pcap_secs', x_range);
          for (var idx in to_plot) {
            add_scale(to_plot[idx], y_range);
          }
        }

        function sanitize_dataset() {
          log('Before filtering: ' + dataset.length);
          dataset = dataset.filter(function(d) {
            if (!d.hasOwnProperty('pcap_secs')) return false;
            if (raw('pcap_secs')(d) <= 0) return false;

            if (!d.hasOwnProperty('ta') || !d.hasOwnProperty('ra'))
              return false;

            for (var idx in to_plot) {
              if (!d.hasOwnProperty(to_plot[idx])) return false;
            }
            return true;
          });
          log('After filtering: ' + dataset.length);
        }

        function add_scale(field, range) {
          scales[field] = settings(field)['scale_type']
            .domain([d3.min(dataset, raw(field)),
              d3.max(dataset, raw(field))])
            .range(range);
        }

        function raw(name) {
          return function(d) {
            return settings(name)['parser'](d[name]);
          }
        }

        function scaled(name) {
          return function(d) {
            return scales[name](settings(name)['parser'](d[name]));
          }
        }

        function draw() {
          add_butter_bar();

          for (var idx in to_plot) {
            visualize(to_plot[idx]);
          }
          add_legend();
        }

        function add_butter_bar() {
          var svg = d3
            .select('body')
            .append('svg')
            .attr('id', 'butter_bar')
            .attr('width', width)
            .attr('height', padding);
          svg.append('rect')
            .attr('id', 'butter_bar_box')
            .attr('width', width)
            .attr('height', padding)
            .style('fill', 'none');
          svg.append('text')
            .attr('id', 'butter_bar_msg')
            .attr('class', 'legend')
            .attr('x', width / 2 - 4 * padding)
            .attr('y', 2 + padding / 2)
            .style('fill', 'black')
            .style('font-size', 14);
        }

        function add_legend() {
          var svg = d3
            .select('body')
            .append('svg')
            .attr('id', 'legend')
            .attr('width', width)
            .attr('height', height);

          var font_width = 6;
          var key_length = font_width * ((12 + 5) * 2 + 1);
          var total_length = key_length + 4.5 * padding;
          var n_cols = Math.floor(total_width / total_length);

          stream2packets.forEach(function(d, i) {
            var col = i % n_cols;
            var row = Math.floor(i / n_cols);
            svg.append('text')
              .attr('id', 'legend_' + to_valid_selector_id(d.key))
              .attr('x', col * total_length + 2 * padding)
              .attr('y', (row + 1.5) * padding)
              .attr('class', 'legend')
              .text(d.key)
              .on('click', function(){
                select_stream(this.id.match(/legend_(.*)/)[1]);
            });
          });
        }

        function butter_bar(text) {
          d3.select('text#butter_bar_msg')
            .style('opacity', 1)
            .text(text);
          d3.select('rect#butter_bar_box')
            .style('opacity', 1)
            .style('fill', 'red');
          d3.select('text#butter_bar_msg')
            .transition()
            .duration(1500)
            .style('opacity', 0);
          d3.select('rect#butter_bar_box')
            .transition()
            .duration(500)
            .style('opacity', 0);
        }


        var details = d3.select('#tooltip')
                        .style('top',  (2 * padding) + 'px')
                        .classed('hidden', true)
                        .append("svg")
                        .attr("width", 200)
                        .attr("height", availableMetrics.length * tooltipLabelsHeight);

        function visualize(field) {
          log('About to visualize ' + field);

          var svg = d3
            .select('body')
            .append('svg')
            .attr('id', 'plot_' + field)
            .attr('width', width)
            .attr('height', height);

          var focus = svg.append('g')
            .attr("class", "focus")
            .style('display', null);

          reticle[field] = focus;

          stream2packets.forEach(function(d, i) {
            var current_plot_id = 'pcap_vs_' + field + '_' + to_valid_selector_id(d.key);
            log(d.key + "(" + d.values.length + ")");

            svg
              .selectAll(current_plot_id)
              .data(d.values)
              .enter()
              .append('circle')
              .attr('class', 'points')
              .attr('cx', scaled('pcap_secs'))
              .attr('cy', scaled(field))
              .attr('fill', 'grey')
              .attr('r', 2)
              .attr('id', current_plot_id);
          });

          // TODO(katepek): Axes seem to show range, not the domain
          var pcapSecsAxis = d3.svg.axis()
            .scale(scales['pcap_secs'])
            .tickFormat(hourMinuteMilliseconds)
            .orient('bottom')
            .ticks(5);
          var yAxis = d3.svg.axis()
            .scale(scales[field])
            .orient('right')
            .ticks(5);
          
          svg.append('g')
            .attr('class', 'axis')
            .attr('transform', 'translate(0,' + (height - 1.5 * padding) + ')')
            .call(pcapSecsAxis);
          svg.append('g')
            .attr('class', 'axis')
            .attr('transform', 'translate(' + (width - 3 * padding) + ',0)')
            .call(yAxis);

          // Add crosshairs
          focus.append('line')
            .attr('class', 'x')
            .attr('y1', 0)
            .attr('y2', height);

          focus.append('line')
            .attr('class', 'y')
            .attr('x1', 0)
            .attr('x2', width);

          focus.append('circle')
            .attr('class', 'y')
            .attr('r', 7);

          focus.append('text')
            .attr('class', 'y1')
            .attr('dx', 8)
            .attr('dy', '-.5em');

          // append the rectangle to capture mouse movements
          svg.append('rect')
              .attr('width', width)
              .attr('height', height)
              .style('fill', 'none')
              .style('pointer-events', 'all')
              .on('mouseover', function() {
                for (var i in Object.keys(reticle)) {
                  var current = reticle[Object.keys(reticle)[i]];
                  current.style('display', null);
                  current.select('.y').style('display', null);
                  current.select('circle.y').style('display', null);
                  current.select('text.y1').style('display', null);
                }
              })
              .on('mouseout', function() {
                var x = d3.mouse(this)[0];
                if (x < scales['pcap_secs'].range()[0] ||
                    x > scales['pcap_secs'].range()[1]) {
                    d3.select('#tooltip').classed("hidden", true)
                    for (var i in Object.keys(reticle)) {
                      reticle[Object.keys(reticle)[i]].style('display', 'none');
                    }
                }
              })
              .on('click', function() {
                d = find_packet(d3.mouse(this)[0], d3.mouse(this)[1], field);
                if (!d) return;
                select_stream(to_valid_selector_id(to_stream_key(d)));
                draw_crosshairs(d, field);
              })
              .on('mousemove', function() {
                d = find_packet(d3.mouse(this)[0], d3.mouse(this)[1], field);
                if (!d) return;
                draw_crosshairs(d, field);
              });
        }

        function binary_search_by(field) {
          return d3.bisector(raw(field)).left;
        }

        function find_packet(x, y, field) {
          if (x < scales['pcap_secs'].range()[0] ||
              x > scales['pcap_secs'].range()[1] ||
              y > total_height)
            return;

          var pcap_secs = scales['pcap_secs'].invert(x);
          var search_in = dataset;

          // this mouseover to a particular stream - will maintain functionality for now
          if (selected_stream) {
            search_in = selected_stream.values;
          }

          var idx = binary_search_by('pcap_secs')(search_in, pcap_secs, 0);
          d = closest_to_y(search_in, idx, x, y, scaled(field), field);

          return d;
        }

        function closest_to_y(search_in, idx, x, y, scaled_y, field) {
          var idx_range = 50;
          var x_range = 10;
          var scaled_x = scaled('pcap_secs');

          if(search_in.length > 1){
            idx = Math.abs(x - scaled_x(search_in[idx - 1])) >
                  Math.abs(x - scaled_x(search_in[idx])) ?
                  idx : idx - 1;
          } else {
            idx = 0;
          }
          var begin = Math.max(0, idx - idx_range);
          var end = Math.min(search_in.length - 1, idx + idx_range);

          var closest_idx = idx;

          var min_x = Math.abs(x - scaled_x(search_in[idx]));
          var min_y = Math.abs(y - scaled_y(search_in[idx]));

          for (var i = begin; i <= end; i++) {
            if (Math.abs(x - scaled_x(search_in[i])) > x_range) {
              continue; // too far away
            }
            if (Math.abs(y - scaled_y(search_in[i])) < min_y ||
              (Math.abs(y - scaled_y(search_in[i])) == min_y &&
                Math.abs(x - scaled_x(search_in[i])) < min_x)) {
              min_x = Math.abs(x - scaled_x(search_in[i]));
              min_y = Math.abs(y - scaled_y(search_in[i]));
              closest_idx = i;
            }
          }

          return search_in[closest_idx];
        }

        function draw_crosshairs(d, field) {
          var detailedInfo = d;

          for (var i in Object.keys(reticle)) {
            var r_field = Object.keys(reticle)[i];

            var closest_x = scaled('pcap_secs')(d);
            var closest_y = scaled(r_field)(d);

            reticle[r_field].select('.x')
              .attr('transform', 'translate(' + closest_x + 10 + ',0)');
            reticle[r_field].select('.y')
              .attr('transform', 'translate(0,' + closest_y + ')');

            reticle[r_field].select('circle.y')
                .attr('transform',
                      'translate(' + closest_x + ',' + closest_y + ')');
            }

            d3.select('#tooltip')
              .classed('hidden', false).select("svg")
              .selectAll('.tooltipValues')
                .data(availableMetrics)
                .enter()
                .append("text")
                  .attr("class", "tooltipValues")
                  .attr("y", function(k,i){return i * tooltipLabelsHeight + 10})
                    .text(function(k){return k + ": " + detailedInfo[availableMetrics]});

            d3.selectAll(".tooltipValues")
              .data(availableMetrics)
                .text(function(k){return k + ": " + detailedInfo[k]});

        }

        function select_stream(streamId) {
          // unselect all legends
          d3.selectAll(".legend").classed("selected", false);
          // unselect all points
          d3.selectAll(".points").attr("fill", "grey")

          // if new stream selected, update view & selected stream
          if (!selected_stream || streamId != to_valid_selector_id(selected_stream.key)){
            // select current legend
            d3.select('#legend_' + streamId).classed("selected", true);
            // select these points
            for (var idx in to_plot){ 
              d3.selectAll('#pcap_vs_' + to_plot[idx] + '_' + streamId).attr("fill", "red")
            }
            // update selected_stream key/value pair
            for (var idx in stream2packets) {
              if (to_valid_selector_id(stream2packets[idx].key) == streamId) {
                // set selected_stream so that it's locked to that stream when mousing over
                butter_bar('Locked down to ' + stream2packets[idx].key);
                selected_stream = stream2packets[idx];
                break;
              }
            }
          } else {
            selected_stream = null;
            butter_bar('Unlocked')
          }
        }

        // time formatting functions
        function hourMinuteMilliseconds(d) {
          return d3.time.format("%H:%M:%S")(new Date(d * 1000))
        }

        function milliseconds(d) {
          return d3.time.format("%L")(new Date(d * 1000))
        }
        

      </script>

  </body>
</html>
